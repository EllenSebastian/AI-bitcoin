"""
This file takes a policy, and a history of bitcoin prices, 
and finds the revenue generated by following the policy.
"""
import BitcoinMDP
execfile('dataFetcher.py')
priceData = pickle.load(open('../data/bitcoin_prices.pickle'))


class PolicyTest: 
	# method is "mdp" or "csp"
	def __init__(self, initial_bitcoins = 3, start_deviation = 2, price_resolution = 1, 
		price_range = [-100,100], max_deviation = 3, total_time = 24, btc_bought_at = 300): 
		self.initial_bitcoins = initial_bitcoins
		self.start_deviation = start_deviation
		self.price_resolution = price_resolution
		self.price_range = price_range
		self.max_deviation = max_deviation
		self.btc_bought_at = btc_bought_at
		self.total_time = total_time
		mdp = BitcoinMDP.BitcoinMDP(total_time, initial_bitcoins, start_deviation, 
		   	 price_resolution, price_range , max_deviation )
		vio = BitcoinMDP.ValueIteration()
		vio.solve(mdp)
		self.policy = vio.pi

	def aggregated_prices(self, prices, start_timestamp, end_timestamp, aggregation= 60, returnT="arr"): 
		"""
		------------------------------------------------------------------------------
		prices - dict of unix timestamps to price
		end_timestamp - unix timestamp at which the procurement ends 
		n-aggregates - number of (timestamp : price) elements returned
		aggregation - number of seconds to aggregate over 
		return list of prices in chronological order ending at end_timestamp
		------------------------------------------------------------------------------
		"""
		try: 
			n_aggregates = (end_timestamp - start_timestamp) / aggregation
			sorted_timestamps = sorted([x for x in prices.keys() if x >= start_timestamp and x <= end_timestamp])
			if returnT == "arr": out = []
			else: out = {}
			cur_ts = 0
			for i in range(n_aggregates): 
				matches = []
				while sorted_timestamps[cur_ts] < (start_timestamp + aggregation): 
					cur_ts += 1
					matches.append(prices[sorted_timestamps[cur_ts]])
				if returnT == "arr":
					out.append(np.mean(matches))
				else:
					out[start_timestamp] = np.mean(matches)
				start_timestamp += aggregation
			return out 
		except Exception, e:
			pdb.set_trace() 

	def simulate(self, start_ts, timestep = 3600, windowSize = 10, numFeatures = 100, numDataPoints = 1000):
		end_ts = start_ts + self.total_time * timestep
		actual_prices = self.aggregated_prices(priceData, start_ts - timestep, end_ts, timestep, 'hash')
		real_max_profit = self.initial_bitcoins * (max(actual_prices.values()) - self.btc_bought_at)
		#net = NeuralNetwork(windowSize, numFeatures, numDataPoints, timestep)
		cur_actual_price = actual_prices[start_ts - timestep]
		btcleft = self.initial_bitcoins
		tp, tn, fp, fn, profit, predicted_profit = 0,0,0,0,0,0

		for ts in xrange(start_ts, end_ts, timestep):
			#predicted_price = net.predict(ts)
			predicted_price = actual_prices[ts]
			if (actual_prices[ts] < 0 and predicted_price < 0):
				tn += 1
			elif (actual_prices[ts] > 0 and predicted_price > 0):
				tp += 1 
			if (actual_prices[ts] > 0 and predicted_price < 0):
				fn += 1
			elif (actual_prices[ts] < 0 and predicted_price > 0):
				fp += 1 
			timeleft = (end_ts - ts) / timestep
			curpreddiff = int(round(predicted_price - self.btc_bought_at))  #predicted price - bought price 
			state = (timeleft, btcleft, curpreddiff, self.start_deviation)
			try: 
				action = self.policy[state]
			except: 
				pdb.set_trace()
			if action > btcleft: 
				action = btcleft
			btcleft -= action
			profit += (actual_prices[ts] - self.btc_bought_at) * action
			predicted_profit += curpreddiff * action
			print "profit += ({0} - {1}) * {2}".format(actual_prices[ts], self.btc_bought_at, action)
			print "predicted_profit += {0} * {1}".format(curpreddiff, action)

		print 'error rate: {0}, tp: {1}, tn: {2}, fp: {3}, fn: {4}'.format(fn + fp/float(fn + fp + tn + tp), tp, tn, fp, fn)
		print "predicted_profit: {0}, profit: {1}".format(predicted_profit, profit)
		print "max profit: {0}".format(real_max_profit)
		# get predicted price
		# construct state: timeleft, bitcoins left, curprice-predicted price std

p = PolicyTest(btc_bought_at=390)
p.simulate(start_ts = 1413590400)

"""
import PolicyTest 
p = PolicyTest.PolicyTest()
p.simulate(start_ts = 1413676800)
--> perfect predictions: error rate: 0.0, tp: 24, tn: 0, fp: 0, fn: 0
						predicted_profit: 265, profit: 265.336666667
max profit: 271.9045

p.simulate(start_ts = 1413590400)

error rate: 0.0, tp: 24, tn: 0, fp: 0, fn: 0
predicted_profit: 232, profit: 231.9595
max profit: 276.2235

p = PolicyTest(btc_bought_at=400)
p.simulate(start_ts = 1413590400)
error rate: 0.0, tp: 24, tn: 0, fp: 0, fn: 0
predicted_profit: 0, profit: 0.0
max profit: -23.7765

"""
# get predicted price
# use MDP to find action
# perform that action at current time stamp 
